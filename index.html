<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/02/test/" class="article-date">
  <time datetime="2020-12-02T13:42:13.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/02/test/">test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://hexo-1255798954.cos.ap-beijing.myqcloud.com/hexo/1.png"></p>
<p><img src="https://hexo-1255798954.cos.ap-beijing.myqcloud.com/hexo/2.png"></p>
<p><img src="https://hexo-1255798954.cos.ap-beijing.myqcloud.com/hexo/3.png"></p>
<p><img src="https://hexo-1255798954.cos.ap-beijing.myqcloud.com/hexo/4.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/test/" data-id="ckibpb0eo00138cj0d58b2vk1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CloudBoot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/03/CloudBoot/" class="article-date">
  <time datetime="2019-01-03T08:50:21.000Z" itemprop="datePublished">2019-01-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/03/CloudBoot/">CloudBoot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一-CloudBoot"><a href="#一-CloudBoot" class="headerlink" title="一. CloudBoot"></a>一. CloudBoot</h1><p>CloudBoot 云启装机平台是由云霁科技开发的开源X86服务器配置安装工具，俗称运维人员的“番茄花园”。云霁科技以运维行业的用户痛点和需求为出发点，融合开源软件、互联网服务器运维经验和各大服务器厂商在运维工具的积累，实现统一全自动的X86服务器裸机配置和操作，并联合国内各大服务器厂商，从源头解决问题，形成物理服务器的生产、测试、交付的最佳实践。</p>
<p>对物理服务器的运维人员而言，不需再关心不同品牌类型的服务器和操作系统，只需专注于资源需求。安装1000台不同品牌和不同操作系统的服务器，达到“番茄花园”安装1台windows类似的效果，服务器上架后即装即用。      </p>
<p>  产品特点如下：<br> 1.服务器上架加电后，无需人工干预，实现从硬件配置、操作系统安装、主机名IP配置等完全闭环的自动化。  </p>
<p>  2.支持主流的x86服务器的硬件配置功能（包括RAID/OOB/BIOS等），联合国内硬件厂商整合，支持主流的服务器品牌。  </p>
<p>   3.基于标准的IPMI接口通过带外对服务器进行控制安装，下一个版本还会支持下一代的Redfish协议。  </p>
<p> 4.支持企业级操作系统的自动化安装配置，包括RedHat/CentOS/SUSE等；自带简易的CMDB，可用于资产管理。<br>5.支持一键安装部署，一分钟时间搞定一周的工作。  </p>
<p>  6.支持在线或者离线升级，也灵活的允许用户自定义配置。<br>7.完全免费开源，支持二次开发。  </p>
<p>支持厂商：<br>华为、H3C、Dell、HP、浪潮、IBM、联想等  </p>
<p>支持系统：<br>RedHat、CentOS、SUSE、Ubuntu、Windows Server 2012、Windows Server2008、VMware Esxi等<br>官网地址：<a target="_blank" rel="noopener" href="http://idcos.com/store/cloudboot">http://idcos.com/store/cloudboot</a><br>GitHub：<a target="_blank" rel="noopener" href="https://github.com/idcos/osinstall">https://github.com/idcos/osinstall</a><br>下载地址：<a target="_blank" rel="noopener" href="https://github.com/idcos/osinstall/archive/master.zip">https://github.com/idcos/osinstall/archive/master.zip</a>     </p>
<hr>
<h1 id="二-CloudBoot安装"><a href="#二-CloudBoot安装" class="headerlink" title="二. CloudBoot安装"></a>二. CloudBoot安装</h1><p>2.1   Cloudboot依赖系统RedHat/CentOS 6.0以上版本，对系统安装的包没有要求，最小化安装即可。<br>2.2 关闭防火墙和selinux（需要重启）  </p>
<h2 id="2-3-安装软件包"><a href="#2-3-安装软件包" class="headerlink" title="2.3 安装软件包"></a>2.3 安装软件包</h2><p> <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1Rg0yhG60mpImKs7XdF_xaA">https://pan.baidu.com/s/1Rg0yhG60mpImKs7XdF_xaA</a>  </p>
<pre><code>[root@localhost opt]# IP=192.168.0.112 rpm -ivh cloudboot-1.4-1.x86_64.rpm
Preparing...                          ################################# [100%]
Updating / installing...
1:cloudboot-1.4-1                  ################################# [100%]

此处IP=地址，请根据实际情况选择本机Cloudboot-serve的IP地址</code></pre>
<h2 id="2-4-增加dhcp网段"><a href="#2-4-增加dhcp网段" class="headerlink" title="2.4 增加dhcp网段"></a>2.4 增加dhcp网段</h2><pre><code> [root@localhost opt]# vi /opt/cloudboot/etc/dhcp/dhcpd.conf
 [root@localhost opt]# more /opt/cloudboot/etc/dhcp/dhcpd.conf
 allow booting;
 allow bootp;
 ddns-update-style none;
 ping-check true;
 ping-timeout 3;
 default-lease-time 120;
 max-lease-time 600;
 authoritative;
 next-server osinstall.idcos.com;
 filename &quot;undionly.kkpxe&quot;;
 option domain-name &quot;idcos.com&quot;;
 option domain-name-servers 192.168.0.112;
 option root-path &quot;osinstall.idcos.com:/&quot;;
 subnet 192.168.0.0 netmask 255.255.255.0 &#123;
    range 192.168.0.2 192.168.0.250;
    option routers 192.168.0.112;
 &#125;</code></pre>
<h2 id="2-5-导入iso系统安装介质"><a href="#2-5-导入iso系统安装介质" class="headerlink" title="2.5 导入iso系统安装介质"></a>2.5 导入iso系统安装介质</h2><pre><code>[root@localhost ~]# mount /dev/cdrom /mnt
mount: /dev/sr0 is write-protected, mounting read-only
[root@localhost ~]# rsync -az /mnt/ /opt/cloudboot/home/www/rhel/7.2/os/x86_64/</code></pre>
<h2 id="2-6-修改ftp地址"><a href="#2-6-修改ftp地址" class="headerlink" title="2.6 修改ftp地址"></a>2.6 修改ftp地址</h2><pre><code>[root@localhost ~ pxelinux.cfg]# pwd
/opt/cloudboot/var/lib/tftpboot/pxelinux.cfg
[root@localhost ~ pxelinux.cfg]# vim default
DEFAULT menu.c32
PROMPT 0
TIMEOUT 30

 LABEL bootos
 MENU LABEL ^BootOS
MENU DEFAULT
KERNEL http://192.168.0.112/bootos/vmlinuz
APPEND initrd=http://192.168.0.112/bootos/initrd.img console=tty0 selinux=0 biosdevname=0 SERVER_ADDR=http://192.168.0.112 DEVELOPER=1
IPAPPEND 2</code></pre>
<h2 id="2-7-启动Cloudboot服务"><a href="#2-7-启动Cloudboot服务" class="headerlink" title="2.7 启动Cloudboot服务"></a>2.7 启动Cloudboot服务</h2><pre><code>[root@localhost ~]# service cloudboot start
Starting dhcpd:                                            [  OK  ]
Starting dnsmasq:                                          [  OK  ]
Starting xinetd:                                           [  OK  ]
Starting nginx:                                            [  OK  ]
Starting SMB services:                                     [  OK  ]
Starting mysqld:                                           [  OK  ]
Starting cloudboot-server:                                 [  OK  ]  </code></pre>
<h2 id="2-8-访问Cloudboot"><a href="#2-8-访问Cloudboot" class="headerlink" title="2.8 访问Cloudboot"></a>2.8 访问Cloudboot</h2><p>初始用户名密码（admin/admin）<br><img src="https://i.imgur.com/65GXYFN.png"></p>
<p><img src="https://i.imgur.com/wHax0XE.png"></p>
<hr>
<h1 id="三-配置Cloudboot"><a href="#三-配置Cloudboot" class="headerlink" title="三 .配置Cloudboot"></a>三 .配置Cloudboot</h1><h2 id="3-1-添加应用网段"><a href="#3-1-添加应用网段" class="headerlink" title="3.1 添加应用网段"></a>3.1 添加应用网段</h2><p>请根据实际情况添加相应网段信息<br><img src="https://i.imgur.com/hbQj2pH.png"></p>
<h2 id="3-2-Cloudboot录入新设"><a href="#3-2-Cloudboot录入新设" class="headerlink" title="3.2 Cloudboot录入新设"></a>3.2 Cloudboot录入新设</h2><p>客户端进BOOTOS<br><img src="https://i.imgur.com/WdwvofG.png"></p>
<p><img src="https://i.imgur.com/Zy3n7Fu.png">  </p>
<h2 id="3-3-发现安装新设备"><a href="#3-3-发现安装新设备" class="headerlink" title="3.3 发现安装新设备"></a>3.3 发现安装新设备</h2><p><img src="https://i.imgur.com/sKPdw7G.png"></p>
<p><img src="https://i.imgur.com/GQLVzbk.png">  </p>
<p>提交后自动安装系统，通过正在安装的设备里查看安装进度<br><img src="https://i.imgur.com/O6wyf9s.png"></p>
<p><img src="https://i.imgur.com/msiRLSM.png"></p>
<p><img src="https://i.imgur.com/pXmigUP.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/01/03/CloudBoot/" data-id="ckibpb0dw00008cj0afsz91b0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LVS集群-NAT模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/01/LVS%E9%9B%86%E7%BE%A4-NAT%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2019-01-01T03:36:19.000Z" itemprop="datePublished">2019-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/LVS/">LVS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/01/LVS%E9%9B%86%E7%BE%A4-NAT%E6%A8%A1%E5%BC%8F/">LVS集群-NAT模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一-集群概述"><a href="#一-集群概述" class="headerlink" title="一.集群概述"></a>一.集群概述</h1><p> 一组各自相互独立且又相互依赖的,通过高速网络互联的计算机组成的一个计算机组, 以单一的系统模式加以管理, 为用户提供服务, 对用户来说, 用户只会认为对方是一个服务.  这个里面, 一组计算机的一台计算机就是集群的一个节点  </p>
<h2 id="1-1-集群的种类："><a href="#1-1-集群的种类：" class="headerlink" title="1.1 集群的种类："></a>1.1 集群的种类：</h2><p>集群系统主要分为<br>   负载均衡(Load Balance)集群，简称LB<br>   高可用(High Availability)集群，简称 HA 集群<br>  高性能计算(High Perfermance Computing)集群，简称 HPC 集群  </p>
<h2 id="1-2-LB实现手段"><a href="#1-2-LB实现手段" class="headerlink" title="1.2  LB实现手段"></a>1.2  LB实现手段</h2><p>硬件的实现：  – F5 负载均衡器<br>软件的实现：  – LVS(4层，传输层)  – Nginx(7层，应用层)   </p>
<hr>
<h1 id="二-LVS集群"><a href="#二-LVS集群" class="headerlink" title="二. LVS集群"></a>二. LVS集群</h1><p>LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一，是根据iptables的实现来开发的，所以使用时候会和iptables相当类似<br>官网：      <a target="_blank" rel="noopener" href="http://www.linuxvirtualserver.org/">http://www.linuxvirtualserver.org/</a><br> 中文站点： <a target="_blank" rel="noopener" href="http://zh.linuxvirtualserver.org/">http://zh.linuxvirtualserver.org/</a></p>
<p>LVS 集群工作结构图：  </p>
<p><img src="https://i.imgur.com/7585T7V.png">  </p>
<p>  负载调度器,：分发器(Load Balancer, Director): 整个集群对外的最前端机, 负责接收用户请求, 并且根据自己的调度算法, 将请求转发到后端真实服务器上的动作，而客户认为服务是来自一个IP地址（我们可称之为VIP虚拟IP地址）上的。  </p>
<p>   服务器池: Server Pool  真正为用户提供服务的服务器, 每一台服务器就是一台RS[RealServer]，执行的服务有WEB、MAIL、FTP和DNS等。  </p>
<p>   共享存储: Shared Storaged 为RS保持相同内容, 提供数据的一致性，也就是说，它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。  </p>
<h2 id="2-1-LVS模式及工作原理"><a href="#2-1-LVS模式及工作原理" class="headerlink" title="2.1 LVS模式及工作原理"></a>2.1 LVS模式及工作原理</h2><p>LVS(4层)  模式：<br>  LVS/NAT<br>  LVS-VS/DR<br>  LVS/TUN<br>   LVS负载均衡的三种包转发方式:<br>LVS提供了三种包转发方式：NAT(网络地址映射)、IP Tunneling(IP隧道)、Direct Routing(直接路由)。不同的转发模式决定了不同的cluster的网络结构  </p>
<hr>
<p>NAT(网络地址映射)  </p>
<p>NAT: 网络地址转换<br>DNAT: 目标地址转换  改变的是目标地址<br>SNAT: 原地址转换 改变的是原地址<br>LVS-NAT 就是使用的SNAT和DNAT完成报的转发<br>NAT方式可支持任何的操作系统，以及私有网络，并且只需一个Internet IP地址，但是整个系统的性能受到限制。因为执行NAT每次需要重写包，有一定的延迟；另外，大部分应用有80%的数据是从服务器流向客户机，也就是用户的请求非常短，而服务器的回应非常大，对负载均衡器形成很大压力，成为了新的瓶颈。  </p>
<hr>
<p> IP Tunneling(IP隧道)  </p>
<p>director（分发器）分配请求到不同的real server。real server处理请求后直接回应给用户，这样director负载均衡器仅处理客户机与服务器的一半连接。IP Tunneling技术极大地提高了director的调度处理能力，同时也极大地提高了系统能容纳的最大节点数，可以超过100个节点。real server可以在任何LAN或WAN上运行，这意味着允许地理上的分布，这在灾难恢复中有重要意义。服务器必须拥有正式的IP地址用于与客户机直接通信，并且所有服务器必须支持IP隧道协议。 </p>
<hr>
<p> Direct Routing(直接路由)   </p>
<p>与IP Tunneling类似，负载均衡器仅处理一半的连接，避免了新的性能瓶颈，同样增加了系统的可伸缩性。Direct Routing与IP Tunneling相比，没有IP封装的开销，但由于采用物理层（修改MAC地址）技术，所有服务器都必须在一个物理网段。  </p>
<hr>
<h2 id="2-2-LVS-NAT-模式工作原理："><a href="#2-2-LVS-NAT-模式工作原理：" class="headerlink" title="2.2  LVS-NAT 模式工作原理："></a>2.2  LVS-NAT 模式工作原理：</h2><p>   客户端访问调度器时，调度器通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。  </p>
<h1 id="三-配置LVS-NAT"><a href="#三-配置LVS-NAT" class="headerlink" title="三.配置LVS-NAT"></a>三.配置LVS-NAT</h1><p><img src="https://i.imgur.com/RTx5jnb.png"></p>
<p> 配置LVS：  </p>
<p>xuegod63配置成分发器：  </p>
<p>1、打开路由转发功能  </p>
<pre><code>[root@xuegod63 ~]# vim /etc/sysctl.conf  
 改：net.ipv4.ip_forward = 0
为：net.ipv4.ip_forward = 1</code></pre>
<p> 让配置生效：</p>
<pre><code>[root@xuegod63 ~]# sysctl -p</code></pre>
<p>2、配置网络环境：<br>添加一个网卡（需要两张网卡）， 配置成以下网络环境：<br>eth0  192.168.1.63  模式：br0    模拟公网<br>eth1  192.168.2.63  模式：vmnet4    模拟内网   </p>
<p>3 安装: LVS管理工具： ipvsadmin </p>
<pre><code>[root@xuegod63 Packages]# pwd  
/mnt/Packages
[root@xuegod63 Packages]# rpm -ivh ipvsadm-1.25-9.el6.x86_64.rpm  
或：
yum install ipvsadm    </code></pre>
<p>4 使用ipvsadm命令设置规则： </p>
<pre><code>[root@xuegod63 ~]# ipvsadm -A -t 192.168.1.63:80 -s rr       rr代表轮循  </code></pre>
<p>选项：<br>    -A 添加虚拟服务器<br> -t 表示TCP的服务  VIP：PORT<br> -s 指定调度算法  rr表示round-robin 轮循  </p>
<pre><code>[root@xuegod63 ~]#  ipvsadm -a -t 192.168.1.63:80 -r 192.168.2.64 -m
[root@xuegod63 ~]#  ipvsadm -a -t 192.168.1.63:80 -r 192.168.2.62 -m</code></pre>
<p>选项：<br> -a 表示添加real server的地址<br> -r 指定real server的IP地址<br> -m 表示masquerade 也就是NAT方式的LVS    </p>
<p>5  查看：<br>Ipvsadm命令，用于配置及查看内核IPVS表和算法的工具，类似于iptables  </p>
<pre><code>[root@xuegod63 ~]# ipvsadm -L -n
IP Virtual Server version 1.2.1 (size=4096)
 Prot LocalAddress:Port Scheduler Flags
 -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.1.63:80 rr
 -&gt; 192.168.2.62:80              Masq    1      0          0         
 -&gt; 192.168.2.64:80              Masq    1      0          0        </code></pre>
<p>6  保存配置或规则    </p>
<pre><code>[root@xuegod63 ~]# ipvsadm --save &gt; /etc/sysconfig/ipvsadm
或ipvsadm -S    保存以上的配置
Saving IPVS table to /etc/sysconfig/ipvsadm:           [确定]</code></pre>
<p>7  配置真实服务器  </p>
<p>RealServer：在xuegod62和xuegod64上面配置：  </p>
<p>1、配置IP：REAL SERVER自己的网络相关信息配置成如下：<br>xuegod62： eth0： vmnet4 ： 192.168.2.62  网关： 192.168.2.63<br>xuegod64： eth0： vmnet4 ： 192.168.2.64  网关： 192.168.2.63  </p>
<p>8 配置xuegod64为realserver， 并启web服务  </p>
<pre><code>[root@xuegod64 ~]# yum install -y httpd
[root@xuegod64 ~]# systemctl restart httpd
[root@xuegod64 ~]# echo &quot;192.168.2.64&quot; &gt; /var/www/html/index.html    #（实验期间，各个服务器的页面不同）</code></pre>
<p>9 配置xuegod62为realserver， 并启web服务</p>
<pre><code>[root@xuegod62 ~]# yum install -y httpd
[root@xuegod62 ~]# systemctl restart httpd
[root@xuegod62 ~]# echo &quot;192.168.2.62&quot; &gt; /var/www/html/index.html    #（实验期间，各个服务器的页面不同）</code></pre>
<p>10  测试VIP：<br>    [root@xuegod63 ~]# elinks 192.168.1.63 –dump<br>     192.168.2.62<br>    [root@xuegod63 ~]# elinks 192.168.1.63 –dump<br>     192.168.2.64</p>
<p>访问： 在物理上打开浏览器访问： 每按F5刷新一次，就会变换一个页面。<br><img src="https://i.imgur.com/H40POsZ.png"> </p>
<p>11 扩展ipvsadm 更多参数说明<br> -L -n  ==&gt;  查看规则，显示内核虚拟服务器表<br> -L -n -c ==&gt; 查看客户端连接分发器和real server 的情况   </p>
<p>例：</p>
<pre><code>[root@xuegod63 ~]# ipvsadm -L -n -c
IPVS connection entries
pro expire state       source             virtual            destination
TCP 01:33  TIME_WAIT   192.168.1.100:49698 192.168.1.70:80    192.168.2.62:80
TCP 01:26  TIME_WAIT   192.168.1.100:49690 192.168.1.70:80    192.168.2.64:80
TCP 01:57  TIME_WAIT   192.168.1.100:49739 192.168.1.70:80    192.168.2.62:80
选项：
 -L -n --stats  ==&gt;  查看分发情况
 -L -n --rate  ==&gt; 查看速率
 -Z --zero 虚拟服务表计数器清零（清空当前的连接数量等）</code></pre>
<hr>
<pre><code> [root@xuegod63 ~]# ipvsadm -Z
 [root@xuegod63 ~]# ipvsadm -L -n --stats
 IP Virtual Server version 1.2.1 (size=4096)
 选项：
 -Z --clear 清空IPVS的数据、等信息</code></pre>
<hr>
<pre><code>[root@xuegod63 ~]# ipvsadm -C
选项：
-C    清空所有规则
LVS的规则配置文件：/etc/sysconfig/ipvsadm   </code></pre>
<p>12 ipvsadm命令选项解释<br>-A –add-service    在内核的虚拟服务器表中添加一条新的虚拟服务器记录。也就是增加一台新的虚拟服务器。<br>-E –edit-service      编辑内核虚拟服务器表中的一条虚拟服务器记录。<br>-D –delete-service  删除内核虚拟服务器表中的一条虚拟服务器记录。<br>-C –clear                 清除内核虚拟服务器表中的所有记录。<br>-R –restore             恢复虚拟服务器规则<br>-S –save                 保存虚拟服务器规则，输出为-R 选项可读的格式<br>-a –add-server       在内核虚拟服务器表的一条记录里添加一条新的真实服务器记录。也就是在一个虚拟服务器中增加一台新的真实服务器<br>-e –edit-server       编辑一条虚拟服务器记录中的某条真实服务器记录<br>-d –delete-server    删除一条虚拟服务器记录中的某条真实服务器记录<br>-L|-l –list                  显示内核虚拟服务器表<br>-Z –zero                  虚拟服务表计数器清零（清空当前的连接数量等）<br>–set tcp tcpfin udp  设置连接超时值<br>–start-daemon        启动同步守护进程。他后面可以是master 或backup，用来说明LVS Router 是master 或是backup。在这个功能上也可以采用keepalived的VRRP 功能。<br>–stop-daemon        停止同步守护进程<br>-h –help                  显示帮助信息<br>其他的选项:<br>-t –tcp-service service-address        说明虚拟服务器提供的是tcp 的服务[vip:port] or [real-server-ip:port]<br>-u –udp-service service-address      说明虚拟服务器提供的是udp 的服务[vip:port] or [real-server-ip:port]<br>-f –fwmark-service fwmark               说明是经过iptables 标记过的服务类型。<br>-s –scheduler scheduler                   使用的调度算法，有这样几个选项rr|wrr|lc|wlc|lblc|lblcr|dh|sh|sed|nq,默认的调度算法是： wlc.<br>-p –persistent [timeout]                   持久稳固的服务。这个选项的意思是来自同一个客户的多次请求，将被同一台真实的服务器处理。timeout 的默认值为300 秒。<br>-M –netmask                                    netmask persistent granularity mask<br>-r –real-server server-address         真实的服务器[Real-Server:port]<br>-g –gatewaying                                指定LVS 的工作模式为直接路由模式（也是LVS 默认的模式）<br>-i –ipip                                              指定LVS 的工作模式为隧道模式<br>-m –masquerading                           指定LVS 的工作模式为NAT 模式<br>-w –weight weight                           真实服务器的权值<br>–mcast-interface interface              指定组播的同步接口<br>-c –connection                                  显示LVS 目前的连接 如：ipvsadm -L -c<br>–timeout                                        显示tcp tcpfin udp 的timeout 值 如：ipvsadm -L –timeout<br>–daemon                                          显示同步守护进程状态<br>–stats                                              显示统计信息<br>–rate                                                显示速率信息<br>–sort                                                对虚拟服务器和真实服务器排序输出<br>–numeric -n                                      输出IP 地址和端口的数字形式  </p>
<p>超时时间用ipvsadm –set tcp tcpfin udp设置，<br>比如</p>
<pre><code>ipvsadm --set 120 20 100
表示tcp空闲等待时间为120 秒
客户端关闭链接等待时间为20秒
udp空闲等待为100秒</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/01/01/LVS%E9%9B%86%E7%BE%A4-NAT%E6%A8%A1%E5%BC%8F/" data-id="ckibpb0e700078cj0emasg8td" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Docker私有registry Harbor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/13/Docker%E7%A7%81%E6%9C%89registry%20Harbor/" class="article-date">
  <time datetime="2018-12-13T11:11:23.000Z" itemprop="datePublished">2018-12-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/13/Docker%E7%A7%81%E6%9C%89registry%20Harbor/">Docker私有registry Harbor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一-Harbor-简介"><a href="#一-Harbor-简介" class="headerlink" title="一. Harbor  简介"></a>一. Harbor  简介</h1><p> Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。   </p>
<h2 id="1-1-Harbor组件"><a href="#1-1-Harbor组件" class="headerlink" title="1.1 Harbor组件"></a>1.1 Harbor组件</h2><ul>
<li>Proxy：Harbor的registry, UI, token等服务，通过一个前置的反向代理统一接收浏览器、Docker客户端的请求，并将请求转发给后端不同的服务。   </li>
<li>Registry： 负责储存Docker镜像，并处理docker push/pull 命令。由于我们要对用户进行访问控制，即不同用户对Docker image有不同的读写权限，Registry会指向一个token服务，强制用户的每次docker pull/push请求都要携带一个合法的token, Registry会通过公钥对token 进行解密验证。</li>
<li>Core services： 这是Harbor的核心功能，主要提供以下服务：</li>
<li>UI：提供图形化界面，帮助用户管理registry上的镜像（image）, 并对用户进行授权。</li>
<li>webhook：为了及时获取registry 上image状态变化的情况， 在Registry上配置webhook，把状态变化传递给UI模块。</li>
<li>token 服务：负责根据用户权限给每个docker push/pull命令签发token. Docker 客户端向Regiøstry服务发起的请求,如果不包含token，会被重定向到这里，获得token后再重新向Registry进行请求。</li>
<li>Database：为core services提供数据库服务，负责储存用户权限、审计日志、Docker image分组信息等数据。</li>
<li>Job Services：提供镜像远程复制功能，可以把本地镜像同步到其他Harbor实例中。</li>
<li>Log collector：为了帮助监控Harbor运行，负责收集其他组件的log，供日后进行分析。</li>
<li>Volnerability Scanning：对应启动组件clair。负责镜像扫描</li>
<li>Notary：对应启动组件notary。负责镜像认证</li>
<li>DB：对应启动组件harbor-db，负责存储project、 user、 role、replication、image_scan、access等的metadata数据。  </li>
</ul>
<h2 id="1-2-Harbor实现"><a href="#1-2-Harbor实现" class="headerlink" title="1.2 Harbor实现"></a>1.2 Harbor实现</h2><p>Harbor的每个组件都是以Docker容器的形式构建的，官方也是使用Docker Compose来对它进行部署。用于部署Harbor的Docker Compose模板位于 harbor/docker-compose.yml,打开这个模板文件，发现Harbor是由7个容器组成的；  </p>
<pre><code>[root@aliyun harbor]# cd /usr/local/harbor/ //解压路径
[root@aliyun harbor]# docker-compose ps
Name Command State Ports
    ------------------------------------------------------------------------------------------------------------------------------
harbor-adminserver /harbor/harbor_adminserver Up
harbor-db docker-entrypoint.sh mysqld Up 3306/tcp
harbor-jobservice /harbor/harbor_jobservice Up
harbor-log /bin/sh -c crond &amp;&amp; rm -f ... Up 127.0.0.1:1514-&gt;514/tcp
harbor-ui /harbor/harbor_ui Up
nginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcp
registry /entrypoint.sh serve /etc/ ... Up 5000/tcp</code></pre>
<p>nginx：nginx负责流量转发和安全验证，对外提供的流量都是从nginx中转，所以开放https的443端口，它将流量分发到后端的ui和正在docker镜像存储的docker registry。 </p>
<p>harbor-jobservice：harbor-jobservice 是harbor的job管理模块，job在harbor里面主要是为了镜像仓库之前同步使用的;  </p>
<p>harbor-ui：harbor-ui是web管理页面，主要是前端的页面和后端CURD的接口;  </p>
<p>registry：registry就是docker原生的仓库，负责保存镜像。  </p>
<p>harbor-adminserver：harbor-adminserver是harbor系统管理接口，可以修改系统配置以及获取系统信息。  </p>
<p>这几个容器通过Docker link的形式连接在一起，在容器之间通过容器名字互相访问。对终端用户而言，只需要暴露proxy （即Nginx）的服务端口。 </p>
<p>harbor-db：harbor-db是harbor的数据库，这里保存了系统的job以及项目、人员权限管理。由于本harbor的认证也是通过数据，在生产环节大多对接到企业的ldap中；  </p>
<p>harbor-log：harbor-log是harbor的日志服务，统一管理harbor的日志。通过inspect可以看出容器统一将日志输出的syslog。  </p>
<p> 这几个容器通过Docker link的形式连接在一起，这样，在容器之间可以通过容器名字互相访问。对终端用户而言，只需要暴露proxy （即Nginx）的服务端口。  </p>
<hr>
<h1 id="二-安装Harbor"><a href="#二-安装Harbor" class="headerlink" title="二.安装Harbor"></a>二.安装Harbor</h1><h2 id="2-1-安装准备："><a href="#2-1-安装准备：" class="headerlink" title="2.1 安装准备："></a>2.1 安装准备：</h2><p>Harbor 托管在github上  <a target="_blank" rel="noopener" href="https://github.com/vmware/harbor">https://github.com/vmware/harbor</a><br>安装配置说明 :<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md">https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md</a><br>版本：<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a>  </p>
<p>安装有两种方式，一种是off-line ，一种是on-line，即离线和在线安装，离线安装需要下载的安装包较大，在线安装下载的安装包很小<br>安装前需要安装docker 和  docker-compose  </p>
<h2 id="2-2-安装Harbor"><a href="#2-2-安装Harbor" class="headerlink" title="2.2 安装Harbor"></a>2.2 安装Harbor</h2><blockquote>
<p>下载离线安装包  </p>
</blockquote>
<pre><code>[root@aliyun ~]# wget https://storage.googleapis.com/harbor-releases/harbor-offline-installer-v1.5.2.tgz   </code></pre>
<blockquote>
<p> 解压</p>
</blockquote>
<pre><code> [root@aliyun ~]# tar xf harbor-offline-installer-v1.5.2.tgz  -C /usr/local/</code></pre>
<blockquote>
<p>修改配置文件</p>
</blockquote>
<pre><code> # vim /usr/local/harbor/harbor.cfg 
 hostname = 192.168.10.1 //服务器地址 
 #邮箱配置 email_server = smtp.qq.com 
 email_server_port = 25
 email_username = unixfbi@unixfbi.com 
 email_password =12345678 
 email_from = UnixFBI &lt;unixfbi@unixfbi.com&gt; 
 email_ssl = false #禁止用户注册 
 self_registration = off #设置只有管理员可以创建项目 
 project_creation_restriction = adminonly</code></pre>
<blockquote>
<p>执行安装脚本</p>
</blockquote>
<pre><code> # /usr/local/harbor/install.sh</code></pre>
<blockquote>
<p>Harbor的启动与停止</p>
</blockquote>
<p>Harbor 的日常运维管理是通过docker-compose来完成的，Harbor本身有多个服务进程，都放在docker容器之中运行，我们可以通过 docker-compose 来查看 </p>
<pre><code> [root@aliyun harbor]# cd /usr/local/harbor/ //解压路径
 [root@aliyun harbor]# docker-compose ps
 Name Command State Ports
 ------------------------------------------------------------------------------------------------------------------------------
 harbor-adminserver /harbor/harbor_adminserver Up
 harbor-db docker-entrypoint.sh mysqld Up 3306/tcp
 harbor-jobservice /harbor/harbor_jobservice Up
 harbor-log /bin/sh -c crond &amp;&amp; rm -f ... Up 127.0.0.1:1514-&gt;514/tcp
 harbor-ui /harbor/harbor_ui Up
 nginx nginx -g daemon off; Up 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp, 0.0.0.0:80-&gt;80/tcp
 registry /entrypoint.sh serve /etc/ ... Up 5000/tcp


 Harbor的启动和停止
 启动Harbor
 # docker-compose start
 停止Harbor
 # docker-comose stop
 重启Harbor
 # docker-compose restart </code></pre>
<blockquote>
<p> 访问测试</p>
</blockquote>
<p>浏览器访问 192.168.10.1<br>默认账号密码： admin / Harbor12345 登录后修改密码</p>
<p><img src="https://i.imgur.com/GbaGfu6.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/13/Docker%E7%A7%81%E6%9C%89registry%20Harbor/" data-id="ckibpb0e100018cj04c9ahoor" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Docker镜像管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/12/Docker%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2018-12-12T11:32:57.000Z" itemprop="datePublished">2018-12-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/12/Docker%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/">Docker镜像管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一-关于Docker镜像"><a href="#一-关于Docker镜像" class="headerlink" title="一.关于Docker镜像"></a>一.关于Docker镜像</h1><ul>
<li><p>Docker镜像含有启动容器所需要的文件系统及其内容 ,因此 其用于创建并启动docke镜像.</p>
<ul>
<li><p>采用分层构建机制    最底层为bootfs ,向上为rootfs  </p>
<ul>
<li><p>bootfs:用于系统引导的文件系统,包括bootloader和kernel ,容器启动完成后会被卸载以节约内存资源  </p>
</li>
<li><p>rootfs:位于bootfs之上,变现为docker容器的跟文件系统  </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>      - 传统模式中,系统启动之时,内核挂载tootfs时会首先将其挂载为&quot;只读&quot; 模式,完整性自检完成后将其重新挂载为读写模式  

      - docker中,rootfs由内核挂载为&quot;只读&quot;模式,而后通过&quot;联合挂载&quot;技术额外挂载一个&quot;可写&quot;层;  </code></pre>
<p><img src="https://i.imgur.com/EUUWb3h.png"></p>
<hr>
<h1 id="二-Docker镜像分层"><a href="#二-Docker镜像分层" class="headerlink" title="二.Docker镜像分层"></a>二.Docker镜像分层</h1><ul>
<li>位于下层的镜像称为父镜像,最底层的称为基础镜像(base image) </li>
<li>最上层为”可读写”层,其下的均为”只读”层  <ul>
<li> 当删除容器时 ,可写层会一起删除<br><img src="https://i.imgur.com/lZAwKPC.png">  </li>
</ul>
</li>
</ul>
<hr>
<h1 id="三-Docker存储"><a href="#三-Docker存储" class="headerlink" title="三.Docker存储"></a>三.Docker存储</h1><ul>
<li>启动容器时,docker daemon会试图从本地获取相关的镜像,本地镜像不存在时,其将从Registry中下载该镜像并保存到本地.</li>
</ul>
<pre><code>Registry没有特别指定 默认为docker hub  ,如果使用别的Registry ,则必须在镜像的访问路径给名服务器地址</code></pre>
<hr>
<h1 id="四-Docker-Hub"><a href="#四-Docker-Hub" class="headerlink" title="四.Docker Hub"></a>四.Docker Hub</h1><p>注册账号:<a target="_blank" rel="noopener" href="https://hub.docker.com/signup">https://hub.docker.com/signup</a>   </p>
<pre><code>获取镜像:
#docker pull &lt;registry&gt;[:&lt;port&gt;]/[&lt;namespace&gt;/]&lt;name&gt;:&lt;tag&gt;
&lt;registry&gt;[:&lt;port&gt;]       哪个仓库服务器加端口  docker hub 可省略
/[&lt;namespace&gt;/]          名称空间 哪个用户的仓库 顶层可省略
&lt;name&gt;:&lt;tag&gt;             仓库名加标签名</code></pre>
<p>其他著名仓库服务器:<a target="_blank" rel="noopener" href="https://quay.io/">https://quay.io/</a><br>例:  </p>
<pre><code>[root@Docker ~]# docker pull quay.io/coreos/flannel:v0.10.0-s390x   //端口默认为443</code></pre>
<p><img src="https://i.imgur.com/uuo6iL1.png">   </p>
<hr>
<h1 id="五-镜像相关操作"><a href="#五-镜像相关操作" class="headerlink" title="五.镜像相关操作"></a>五.镜像相关操作</h1><h2 id="5-1-镜像的生成途径"><a href="#5-1-镜像的生成途径" class="headerlink" title="5.1 镜像的生成途径"></a>5.1 镜像的生成途径</h2><ul>
<li>Dockerfile  </li>
<li>基于容器制作</li>
<li>Docker Hub automater builds  </li>
</ul>
<h2 id="5-2-基于容器做镜像"><a href="#5-2-基于容器做镜像" class="headerlink" title="5.2 基于容器做镜像"></a>5.2 基于容器做镜像</h2><h3 id="1-先启动一个容器-做好修改"><a href="#1-先启动一个容器-做好修改" class="headerlink" title="1.先启动一个容器 做好修改"></a>1.先启动一个容器 做好修改</h3><p>先pull busybox镜像 启动后做一个主页 这样下次启动主页就存在   </p>
<pre><code> [root@liujie ~]# docker run --name web1 -it busybox
 / # mkdir /data/html
 mkdir: can&#39;t create directory &#39;/data/html&#39;: No such file or directory
/ # mkdir -p  /data/html
/ # vi /data/html/index.html
hello  httpd
//此时不能关闭容器 </code></pre>
<h3 id="2-基于容器做镜像"><a href="#2-基于容器做镜像" class="headerlink" title="2.基于容器做镜像"></a>2.基于容器做镜像</h3><p>Usage:    docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<br>docker commit [OPTIONS] CONTAINER    基于哪个容器做镜像<br>[REPOSITORY[:TAG]]                                    属于哪个仓库拥有什么标签  如果省略则代表本地的裸镜像 不属于任何仓库  </p>
<pre><code>[root@liujie ~]# docker commit -p web1   //-p是暂停  防止保存部分文件 
sha256:b4ecf4975f3b22284c26be372197aa73029d0781acaeb584456fb624fc1fa934 
[root@liujie ~]# docker image ls
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
&lt;none&gt;                   &lt;none&gt;              b4ecf4975f3b        12 minutes ago      1.15MB
仓库为空                 标签也为空            id为生成id </code></pre>
<p>为了后续管理 可以为打标签  </p>
<pre><code>[root@liujie ~]# docker tag b4ecf4975f3b 18834478096/httpd:v0.1   //基于id  18834478096为docker hub账号为后续上传
[root@liujie ~]# docker image ls
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
18834478096/httpd             v0.1                b4ecf4975f3b        About an hour ago   1.15MB   </code></pre>
<p>删除镜像：  两个标签时可删除  只有一个标签删除会报错  </p>
<pre><code>[root@liujie ~]# docker image rm liujie/httpd:v0.1.1
Untagged: liujie/httpd:v0.1.1   </code></pre>
<h3 id="3-启动做好的镜像"><a href="#3-启动做好的镜像" class="headerlink" title="3. 启动做好的镜像"></a>3. 启动做好的镜像</h3><pre><code>[root@liujie ~]# docker run --name t1 -it 18834478096/httpd:v0.1
/ # cd /
/ # ls
bin   data  dev   etc   home  proc  root  sys   tmp   usr   var
/ #   //之前创建好的data目录存在  </code></pre>
<h2 id="5-3-上传镜像"><a href="#5-3-上传镜像" class="headerlink" title="5.3 上传镜像"></a>5.3 上传镜像</h2><p>放到docker hub上：  </p>
<h3 id="1-注册账号"><a href="#1-注册账号" class="headerlink" title="1.注册账号"></a>1.注册账号</h3><p><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a>  </p>
<h3 id="2-使用Docker-hub账号在验证本地登录"><a href="#2-使用Docker-hub账号在验证本地登录" class="headerlink" title="2.使用Docker hub账号在验证本地登录"></a>2.使用Docker hub账号在验证本地登录</h3><pre><code>[root@liujie ~]# docker login -u 18834478096
Password:
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded</code></pre>
<h3 id="3-查看本地的镜像"><a href="#3-查看本地的镜像" class="headerlink" title="3. 查看本地的镜像"></a>3. 查看本地的镜像</h3><pre><code>[root@liujie ~]# docker image images
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
18834478096/httpd        v0.1                b4ecf4975f3b        3 hours ago         1.15MB</code></pre>
<p>如果REPOITORY的名不是你Docker hub账号和仓库，即Docker ID/仓库名，是上传不成功的   </p>
<h3 id="4-在Docker-Hub上创建仓库"><a href="#4-在Docker-Hub上创建仓库" class="headerlink" title="4.在Docker Hub上创建仓库"></a>4.在Docker Hub上创建仓库</h3><p><img src="https://i.imgur.com/VgVbXMb.png"><br><img src="https://i.imgur.com/aAjpQDV.png"></p>
<h3 id="5-推镜像"><a href="#5-推镜像" class="headerlink" title="5.推镜像"></a>5.推镜像</h3><pre><code>[root@liujie ~]# docker image push 18834478096/httpd:v0.1
The push refers to repository [docker.io/18834478096/httpd]
de66091347b2: Pushed
8a788232037e: Mounted from library/busybox
v0.1: digest: sha256:eccf03eea662b180d52d3c4909bcd82cfc7a7b319c6a4d664643750cdf0544b9 size: 734  </code></pre>
<p><img src="https://i.imgur.com/Ul4GK6Q.png">  </p>
<hr>
<hr>
<hr>
<p>上传阿里镜像仓库  </p>
<p><a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com/</a><br><img src="https://i.imgur.com/1ZPb2zs.png"></p>
<p>选择本地仓库 创建镜像仓库<br><img src="https://i.imgur.com/nIbfC1O.png">  </p>
<p>点击管理<br><img src="https://i.imgur.com/b63MDzu.png"><br><img src="https://i.imgur.com/8alh2dC.png">  </p>
<p>1.给镜像打标签 使用阿里云地址   </p>
<pre><code>[root@liujie ~]# docker image images
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
18834478096/httpd        v0.1                b4ecf4975f3b        3 hours ago         1.15MB
[root@liujie ~]# docker tag 18834478096/httpd:v0.1 registry.cn-qingdao.aliyuncs.com/18834478096/httpd:v0.1
[root@liujie ~]# docker image ls
REPOSITORY                                           TAG                 IMAGE ID            CREATED             SIZE
18834478096/httpd                                    v0.1                b4ecf4975f3b        3 hours ago         1.15MB
registry.cn-qingdao.aliyuncs.com/18834478096/httpd   v0.1                b4ecf4975f3b        3 hours ago         1.15MB</code></pre>
<p>2.登录阿里云   </p>
<pre><code>[root@liujie ~]# docker logout
Removing login credentials for https://index.docker.io/v1/
[root@liujie ~]# docker login --username=18834478096 registry.cn-qingdao.aliyuncs.com
Password:     //密码为Registry登录密码 
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded  </code></pre>
<p>3.推镜像到阿里云  </p>
<pre><code>[root@liujie ~]# docker push registry.cn-qingdao.aliyuncs.com/18834478096/httpd:v0.1
The push refers to repository [registry.cn-qingdao.aliyuncs.com/18834478096/httpd]
de66091347b2: Pushed
8a788232037e: Pushed
v0.1: digest: sha256:eccf03eea662b180d52d3c4909bcd82cfc7a7b319c6a4d664643750cdf0544b9 size: 734   </code></pre>
<p><img src="https://i.imgur.com/lbdBFpk.png">  </p>
<hr>
<h2 id="5-4-镜像导入导出"><a href="#5-4-镜像导入导出" class="headerlink" title="5.4 镜像导入导出"></a>5.4 镜像导入导出</h2><p>打包镜像   </p>
<pre><code> [root@liujie ~]# docker save -o myfirst.gz 18834478096/httpd:v0.1
 [root@liujie ~]# ll
 total 230540
 -rw-------   1 root root    1386496 Dec 19 23:01 myfirst.gz</code></pre>
<p>发送压缩包到其他docker主机使用  </p>
<pre><code>[root@liujie2 ~]# docker load -i myfirst.gz
[root@liujie2 ~]# docker image ls
REPOSITORY                                           TAG                 IMAGE ID            CREATED             SIZE
18834478096/httpd                                    v0.1                b4ecf4975f3b        4 hours ago         1.15MB</code></pre>
<p>这种方法run之前要先pull镜像  不然run还会从默认地址下镜像</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/12/Docker%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/" data-id="ckibpb0e600058cj04cdbcnvs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Docker基础用法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/11/Docker%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/" class="article-date">
  <time datetime="2018-12-11T11:11:23.000Z" itemprop="datePublished">2018-12-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/11/Docker%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/">Docker基础用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p>
<p>CentOS 7 安装Docker CE</p>
<h1 id="一-安装准备"><a href="#一-安装准备" class="headerlink" title="一.安装准备"></a>一.安装准备</h1><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p>
<pre><code>yum remove docker \
docker-client \
docker-client-latest \
docker-common \
docker-latest \
docker-latest-logrotate \
docker-logrotate \
docker-selinux \
docker-engine-selinux \
docker-engine</code></pre>
<hr>
<hr>
<h1 id="二-使用yum安装"><a href="#二-使用yum安装" class="headerlink" title="二.使用yum安装"></a>二.使用yum安装</h1><h2 id="2-1使用清华大学的镜像站"><a href="#2-1使用清华大学的镜像站" class="headerlink" title="2.1使用清华大学的镜像站"></a>2.1使用清华大学的镜像站</h2><p><img src="https://i.imgur.com/u1b2vxf.png"></p>
<pre><code>[root@liujie yum.repos.d]# wget https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo
替换url：
[root@liujie yum.repos.d]# vim docker-ce.repo
:%s@https://download.docker.com/@https://mirrors.tuna.tsinghua.edu.cn/docker-ce/@</code></pre>
<hr>
<h2 id="2-2安装Docker"><a href="#2-2安装Docker" class="headerlink" title="2.2安装Docker"></a>2.2安装Docker</h2><pre><code>[root@liujie yum.repos.d]# yum install docker-ce -y  </code></pre>
<p>解决 docker-ce 安装报错 cont9ainer-selinux &gt;= 2.9</p>
<h3 id="1-下载container-selinux-2-9-4"><a href="#1-下载container-selinux-2-9-4" class="headerlink" title="1. 下载container-selinux-2.9-4"></a>1. 下载container-selinux-2.9-4</h3><p>下载地址： <a href="ftp://ftp.icm.edu.pl/vol/rzm3/linux-centos-vault/7.3.1611/extras/x86_64/Packages/container-selinux-2.9-4.el7.noarch.rpm">ftp://ftp.icm.edu.pl/vol/rzm3/linux-centos-vault/7.3.1611/extras/x86_64/Packages/container-selinux-2.9-4.el7.noarch.rpm</a><br><img src="https://i.imgur.com/DSOLNJ1.png"></p>
<h3 id="2-安装-container-selinux"><a href="#2-安装-container-selinux" class="headerlink" title="2.安装 container-selinux"></a>2.安装 container-selinux</h3><pre><code>[root@liujie yum.repos.d]# yum install container-selinux-2.9-4.el7.noarch.rpm</code></pre>
<hr>
<h2 id="2-3-镜像加速器"><a href="#2-3-镜像加速器" class="headerlink" title="2.3 镜像加速器"></a>2.3 镜像加速器</h2><p>阿里云镜像加速器：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/#/accelerator">https://cr.console.aliyun.com/#/accelerator</a><br>使用配置文件/etc/docker/daemon.json（没有时新建该文件）。  </p>
<pre><code>&#123;
 &quot;registry-mirrors&quot;: [&quot;https://q95dlt3p.mirror.aliyuncs.com&quot;]
&#125;</code></pre>
<p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。    </p>
<hr>
<p>启动docker   </p>
<pre><code>[root@liujie ~]# systemctl restart docker
[root@liujie ~]# docker version
Client:
Version:           18.09.0
API version:       1.39
Go version:        go1.10.4
Git commit:        4d60db4
Built:             Wed Nov  7 00:48:22 2018
OS/Arch:           linux/amd64
Experimental:      false

Server: Docker Engine - Community 
Engine:  Version:          18.09.0  
API version:      1.39 (minimum version 1.12) 
Go version:       go1.10.4   
Git commit:       4d60db4  
Built:            Wed Nov  7 00:19:08 2018  
OS/Arch:          linux/amd64  
Experimental:     false</code></pre>
<hr>
<hr>
<h1 id="三-常用操作"><a href="#三-常用操作" class="headerlink" title="三.常用操作"></a>三.常用操作</h1><p>docker [OPTIONS] COMMAND<br>COMMAND  又为子命令 分为几类<br>建议使用分组的管理命令   </p>
<hr>
<p>3.1 #docker info<br>查看docker系统信息。</p>
<pre><code>[root@liujie ~]# docker info  
Containers: 0    //显示容器个数  
Running: 0   //运行状态的  
Paused: 0   //暂停状态的  
Stopped: 0   //停止状态的  
Images: 3    //有多少个镜像  
Server Version: 18.09.0  
Storage Driver: overlay2   //存储驱动后端  
Backing Filesystem: xfs  
Supports d_type: true  
Native Overlay Diff: true  
Logging Driver: json-file  
Cgroup Driver: cgroupfs  
Plugins:  
Volume: local  
Network: bridge host macvlan null overlay  
Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog  
Swarm: inactive  
..........  
Insecure Registries:  
127.0.0.0/8  
Registry Mirrors:  
https://q95dlt3p.mirror.aliyuncs.com/    //阿里云加速   
Live Restore Enabled: false  
Product License: Community Engine  </code></pre>
<hr>
<p>3.2 #docker search<br>搜索镜像</p>
<p>–automated :只列出 automated build类型的镜像；  </p>
<p>–no-trunc :显示完整的镜像描述；  </p>
<p>-s :列出收藏数不小于指定值的镜像。</p>
<pre><code>[root@liujie ~]# docker search -s 200  redis  
 Flag --stars has been deprecated, use --filter=stars=3 instead  
 NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
 redis               Redis is an open source key-value store that…   6299                [OK]  </code></pre>
<hr>
<p>3.3 #docker image pull<br>从镜像仓库中拉取或者更新指定镜像</p>
<pre><code>[root@liujie ~]# docker image pull nginx:1.14-alpine</code></pre>
<hr>
<p>3.4  #docker images<br>列出本地所以镜像<br>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；<br>–digests :显示镜像的摘要信息；<br>-f :显示满足条件的镜像；<br>–format :指定返回值的模板文件；<br>–no-trunc :显示完整的镜像信息；<br>-q :只显示镜像ID</p>
<pre><code>[root@liujie ~]# docker image images nginx
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               1.14-alpine         d956af1ad36a        13 days ago         17.7MB
nginx               latest              568c4670fa80        3 weeks ago         109MB</code></pre>
<hr>
<p>3.5  #docker image rm    或者docker rmi<br>删除docker镜像<br>而docker rm 则为删除容器    </p>
<pre><code>[root@liujie ~]# docker image rm redis</code></pre>
<hr>
<p>3.6 #docker container create<br>创建容器</p>
<hr>
<p>3.7 # docker container ls   或  # docker ps<br>列出容器 </p>
<hr>
<p>3.8 # docker  container run<br>创建并运行容器</p>
<pre><code>root@liujie ~]# docker container run  --name b1 -it busybox</code></pre>
<hr>
<p>3.9 # docker container stop<br>停止容器  </p>
<pre><code>[root@liujie ~]# docker container stop b2
b2</code></pre>
<hr>
<p>3.10  #docker container rm<br>删除容器<br>删除容器先停止容器  </p>
<pre><code>[root@liujie ~]# docker container rm b1

b1</code></pre>
<hr>
<p>3.11 #docker container logs<br>获取容器的日志  </p>
<pre><code>[root@liujie ~]# docker container logs web1  
172.17.0.1 - - [19/Dec/2018:07:33:38 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;  </code></pre>
<hr>
<p><img src="https://i.imgur.com/jDlxvMv.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/11/Docker%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/" data-id="ckibpb0e400038cj06byi6rb1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Docker简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/10/Docker%E7%AE%80%E4%BB%8B/" class="article-date">
  <time datetime="2018-12-10T11:12:17.000Z" itemprop="datePublished">2018-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/10/Docker%E7%AE%80%E4%BB%8B/">Docker简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/12/10/Docker%E7%AE%80%E4%BB%8B/" data-id="ckibpb0e500048cj008xtglbw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-zabbix配置微信和邮件报警" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/27/zabbix%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%92%8C%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6/" class="article-date">
  <time datetime="2018-11-27T03:45:28.000Z" itemprop="datePublished">2018-11-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Zabbix/">Zabbix</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/27/zabbix%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%92%8C%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6/">zabbix配置微信和邮件报警</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="安装并配置mailx"><a href="#安装并配置mailx" class="headerlink" title="安装并配置mailx"></a>安装并配置mailx</h3><h4 id="安装mailx"><a href="#安装mailx" class="headerlink" title="安装mailx"></a>安装mailx</h4><pre><code> yum install -y mailx</code></pre>
<h4 id="修改mailx配置文件"><a href="#修改mailx配置文件" class="headerlink" title="修改mailx配置文件"></a>修改mailx配置文件</h4><pre><code>vim vim /etc/mail.rc

set from=wang210@163.com  #定义发件人  
set smtp=smtp.163.com  #定义smtp服务器 
set smtp-auth-user=wang210@163.com   
set smtp-auth-password=asdASD123  
set smtp-auth=login  </code></pre>
<h4 id="发送测试邮件"><a href="#发送测试邮件" class="headerlink" title="发送测试邮件"></a>发送测试邮件</h4><pre><code>echo &#39;test1&#39;|mail -s &quot;testmail&quot; .com</code></pre>
<h4 id="编写邮件告警脚本"><a href="#编写邮件告警脚本" class="headerlink" title="编写邮件告警脚本"></a>编写邮件告警脚本</h4><pre><code>vim /usr/lib/zabbix/alertscripts/mail.sh`</code></pre>
<p>这是zabbix默认的脚本路径，可以通过zabbix_server配置文件修改</p>
<pre><code> bash
 #/bin/bash
 to=$1
 subject=`echo $2|tr &#39;\r\n&#39; &#39;\n&#39;`
 message=`echo $3|tr &#39;\r\n&#39; &#39;\n&#39;`
 echo &quot;$message&quot;|mail -s &quot;$subject&quot; $to &gt;&gt;/var/log/mailx.log 2&gt;&amp;1

 touch /var/log/mailx.log
 chown -R zabbix.zabbix /var/log/mailx.log
 chmod +x /usr/lib/zabbix/alertscripts/mail.sh
 ./mail.sh wang210@126.com &quot;主题&quot; &quot;内容&quot;</code></pre>
<h4 id="编辑zabbix-web，配置报警媒介"><a href="#编辑zabbix-web，配置报警媒介" class="headerlink" title="编辑zabbix_web，配置报警媒介"></a>编辑zabbix_web，配置报警媒介</h4><p><img src="http://i2.51cto.com/images/blog/201812/26/4b30209d2fd8e34fddbede58eb5d0e59.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="><br>脚本参数的变量全为大写，是zabbix内置的宏<br>更多关于zabbix的宏可以查看 <a target="_blank" rel="noopener" href="https://www.zabbix.com/documentation/4.0/manual/appendix/macros/supported_by_location">官方文档宏的介绍</a><br>除了使用脚本媒介，也可以使用email作为媒介，相比之下，使用email更简单<br><img src="http://i2.51cto.com/images/blog/201812/26/0dd2ee62175b57174231f0243ce868df.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h4 id="编辑zabbix-web-配置用户"><a href="#编辑zabbix-web-配置用户" class="headerlink" title="编辑zabbix_web,配置用户"></a>编辑zabbix_web,配置用户</h4><p><img src="http://i2.51cto.com/images/blog/201812/26/6dfce1ea7e91282c2af003f9240ff0e3.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<p><img src="http://i2.51cto.com/images/blog/201812/26/d89d480b672450d5266347f765884b65.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h4 id="配置报警动作"><a href="#配置报警动作" class="headerlink" title="配置报警动作"></a>配置报警动作</h4><p>操作，恢复操作，或者更新操作必须存在一个</p>
<h5 id="配置条件"><a href="#配置条件" class="headerlink" title="配置条件"></a>配置条件</h5><p>可以根据自己的需要配置触发条件<br><img src="http://i2.51cto.com/images/blog/201812/26/8014d73a490f194019802c26c0291111.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h5 id="配置操作"><a href="#配置操作" class="headerlink" title="配置操作"></a>配置操作</h5><p>默认标题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;TRIGGER.STATUS&#125;:&#123;TRIGGER.NAME&#125;</span><br></pre></td></tr></table></figure>

<p>消息内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">报警主机：&#123;HOST.NAME&#125;</span><br><span class="line">报警IP：&#123;HOST.IP&#125;</span><br><span class="line">报警时间：&#123;EVENT.DATE&#125;-&#123;EVENT.TIME&#125;</span><br><span class="line">报警等级：&#123;TRIGGER.SEVERITY&#125;</span><br><span class="line">报警信息：&#123;TRIGGER.NAME&#125;：&#123;ITEM.VALUE&#125;</span><br><span class="line">事件ID：&#123;EVENT.ID&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://i2.51cto.com/images/blog/201812/26/bd22df3fccc6b83f94d0b0068dcab6ba.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h5 id="配置恢复操作"><a href="#配置恢复操作" class="headerlink" title="配置恢复操作"></a>配置恢复操作</h5><p>默认标题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;TRIGGER.STATUS&#125;:&#123;TRIGGER.NAME&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消息内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">恢复主机：&#123;HOST.NAME&#125;</span><br><span class="line">恢复IP：&#123;HOST.IP&#125;</span><br><span class="line">恢复时间：&#123;EVENT.DATE&#125;-&#123;EVENT.TIME&#125;</span><br><span class="line">恢复等级：&#123;TRIGGER.SEVERITY&#125;</span><br><span class="line">恢复信息：&#123;TRIGGER.NAME&#125;:&#123;ITEM.VALUE&#125;</span><br><span class="line">恢复ID：&#123;EVENT.ID&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://i2.51cto.com/images/blog/201812/26/3fe7d7252ec3ed0619515cccea210c51.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h4 id="关闭agent，测试报警"><a href="#关闭agent，测试报警" class="headerlink" title="关闭agent，测试报警"></a>关闭agent，测试报警</h4><p><code>systemctl stop zabbix_agent</code><br><img src="http://i2.51cto.com/images/blog/201812/26/66f5765e3a51d384d19f892129900e38.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="><br><code>systemctl start zabbix_agent</code><br><img src="http://i2.51cto.com/images/blog/201812/26/7b610b3290faf31421b7f75f7a4c572b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h3 id="配置微信报警"><a href="#配置微信报警" class="headerlink" title="配置微信报警"></a>配置微信报警</h3><h4 id="注册企业微信"><a href="#注册企业微信" class="headerlink" title="注册企业微信"></a>注册企业微信</h4><p>配置微信报警需要注册<a target="_blank" rel="noopener" href="https://work.weixin.qq.com/wework_admin/frame">企业微信</a></p>
<h4 id="获取企业ID"><a href="#获取企业ID" class="headerlink" title="获取企业ID"></a>获取企业ID</h4><p>点击‘我的企业’到最下面获取<br><img src="http://i2.51cto.com/images/blog/201812/26/b6599f09a564f242de833497f2b8d930.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h4 id="获取AgentID和Secret"><a href="#获取AgentID和Secret" class="headerlink" title="获取AgentID和Secret"></a>获取AgentID和Secret</h4><p>单击应用与小程序，选择下面的创建应用，应用名字自己随便起，最好有象征意义<br><img src="http://i2.51cto.com/images/blog/201812/26/3ff5841c77954523003a60bd00a65de8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<p><img src="http://i2.51cto.com/images/blog/201812/26/9762e8c984e502cc155f5a0fa6e4500b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="><br>然后打开新创建的应用，记录下AgentID和Secret</p>
<h3 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h3><h4 id="从GitHub克隆微信报警脚本"><a href="#从GitHub克隆微信报警脚本" class="headerlink" title="从GitHub克隆微信报警脚本"></a>从GitHub克隆微信报警脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/X-Mars/Zabbix-Alert-WeChat.git</span><br><span class="line">cp Zabbix-Alert-WeChat/wechat.py /usr/<span class="built_in">local</span>/zabbix34/alertscripts/</span><br><span class="line">chmod +x wechat.py &amp;&amp; chown zabbix:zabbix wechat.py</span><br></pre></td></tr></table></figure>
<h4 id="安装requests库"><a href="#安装requests库" class="headerlink" title="安装requests库"></a>安装requests库</h4><p>使用pip安装，需要先下载pip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python  get-pip.py</span><br></pre></td></tr></table></figure>
<p>安装requests库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>
<h4 id="修改wechat-py脚本"><a href="#修改wechat-py脚本" class="headerlink" title="修改wechat.py脚本"></a>修改wechat.py脚本</h4><p>Corpid，Secret，Agentid填写自己企业微信的信息，修改这三个参数即可，当然也可以选择使用标签ID，部门ID，取消注释即可<br><img src="http://i2.51cto.com/images/blog/201812/26/133026e0013bd3ff66cb257c40ac4a4b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<p>修改完成后测试脚本是否可用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python wechat.py 企业微信ID test text</span><br><span class="line">&#123;u&#39;invaliduser&#39;: u&#39;&#39;, u&#39;errcode&#39;: 0, u&#39;errmsg&#39;: u&#39;ok&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在zabbix-web上配置报警媒介和用户"><a href="#在zabbix-web上配置报警媒介和用户" class="headerlink" title="在zabbix_web上配置报警媒介和用户"></a>在zabbix_web上配置报警媒介和用户</h3><h4 id="配置报警媒介"><a href="#配置报警媒介" class="headerlink" title="配置报警媒介"></a>配置报警媒介</h4><p><img src="http://i2.51cto.com/images/blog/201812/26/9be9b96ea260b5481765943ce41aee93.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h4 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h4><p>收件人填写企业微信的用户ID<br><img src="http://i2.51cto.com/images/blog/201812/26/c428cbc26995e56fe763d76be730f51f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h3 id="配置动作"><a href="#配置动作" class="headerlink" title="配置动作"></a>配置动作</h3><h4 id="配置操作-1"><a href="#配置操作-1" class="headerlink" title="配置操作"></a>配置操作</h4><p>消息内容与标题与邮件报警配置相同，只要把发送的媒介通过WeChat发送即可<br><img src="http://i2.51cto.com/images/blog/201812/26/75504adfad809b4fbdb3e99fa63e157c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h4 id="配置恢复操作-1"><a href="#配置恢复操作-1" class="headerlink" title="配置恢复操作"></a>配置恢复操作</h4><p>恢复操作也是把媒介改成通过WeChat发送<br><img src="http://i2.51cto.com/images/blog/201812/26/7e18c7cc7a52fccf8974d470cbc24129.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>
<h3 id="测试微信报警"><a href="#测试微信报警" class="headerlink" title="测试微信报警"></a>测试微信报警</h3><p>重启虚拟机测试,企业微信收到邮件</p>
<p><img src="http://i2.51cto.com/images/blog/201812/26/7682e523da05b253535a4df4d54be955.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk="></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/11/27/zabbix%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%92%8C%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6/" data-id="ckibpb0ep00158cj09jjw4guc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Nginx的https服务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/05/Nginx%E7%9A%84https%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2018-08-05T10:09:17.000Z" itemprop="datePublished">2018-08-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/05/Nginx%E7%9A%84https%E6%9C%8D%E5%8A%A1/">Nginx的https服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="一-HTTPS"><a href="#一-HTTPS" class="headerlink" title="一.HTTPS"></a>一.HTTPS</h1><p>   1.传输数据被中间人盗用，信息泄露<br>   2.数据内容劫持，篡改   </p>
<p>https协议实现：<br>   对传输内容进行加密以及身份验证  </p>
<hr>
<h1 id="二，签名证书生成"><a href="#二，签名证书生成" class="headerlink" title="二，签名证书生成"></a>二，签名证书生成</h1><h2 id="2-1-确保安装了openssl"><a href="#2-1-确保安装了openssl" class="headerlink" title="2.1 确保安装了openssl"></a>2.1 确保安装了openssl</h2><pre><code>[root@liujie ~]# openssl version
OpenSSL 1.0.2k-fips  26 Jan 2017</code></pre>
<hr>
<h2 id="2-2-生成key文件"><a href="#2-2-生成key文件" class="headerlink" title="2.2 生成key文件"></a>2.2 生成key文件</h2><pre><code>[root@liujie ~]# cd /etc/nginx/
[root@liujie nginx]# mkdir ssl_key
[root@liujie nginx]# cd ssl_key/
[root@liujie ssl_key]# openssl genrsa -idea -out jesonc.key 1024    然后输入密码  
[root@liujie ssl_key]# ll
 total 0
 -rw-r--r-- 1 root root 0 Dec 16 03:09 jesonc.key </code></pre>
<hr>
<h2 id="2-3创建签名请求的证书（CSR）"><a href="#2-3创建签名请求的证书（CSR）" class="headerlink" title="2.3创建签名请求的证书（CSR）"></a>2.3创建签名请求的证书（CSR）</h2><pre><code>[root@liujie ssl_key]# openssl req -new -key jesonc.key -out jesonc.csr   //输入密码
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN   //国家
State or Province Name (full name) []:beijing   //省
Locality Name (eg, city) [Default City]:beijing   //市
Organization Name (eg, company) [Default Company Ltd]:CN
Organizational Unit Name (eg, section) []:liujie  //部门
Common Name (eg, your name or your server&#39;s hostname) []:liujie.com   //授权（证书）网址
Email Address []:liujie961010@163.com  //邮箱

Please enter the following &#39;extra&#39; attributes
to be sent with your certificate request
A challenge password []:   //密码  妥善保管
An optional company name []:gongsimingzi  //公司名字 可不填  </code></pre>
<hr>
<h2 id="2-4-根据两文件建立字签名crt证书"><a href="#2-4-根据两文件建立字签名crt证书" class="headerlink" title="2.4  根据两文件建立字签名crt证书"></a>2.4  根据两文件建立字签名crt证书</h2><pre><code>[root@liujie ssl_key]# openssl x509 -req -days 3650 -in jesonc..csr -signkey jesonc..key -out jesonc.crt  
//3650代表证书过期时间
//输入密码  </code></pre>
<hr>
<h2 id="2-5-nginx的https服务器"><a href="#2-5-nginx的https服务器" class="headerlink" title="2.5 nginx的https服务器"></a>2.5 nginx的https服务器</h2><p>配置虚拟server</p>
<p>[root@liujie conf.d]# vim test_https.conf</p>
<pre><code> server  
 &#123;  
 listen       443;
 server_name  10.10.11.221 liujie.com; 
 ssl on; 
 ssl_certificate /etc/nginx/ssl_key/jesonc.crt; 
 ssl_certificate_key /etc/nginx/ssl_key/jesonc.key; 
 #ssl_certificate_key /etc/nginx/ssl_key/jesonc_nopass.key;  

 index index.html index.htm;
 location / &#123;       
      root  /opt/app/code;  
  &#125;
&#125;</code></pre>
<p>重启nginx  查看端口：</p>
<pre><code> [root@liujie run]# netstat  -luntp  | grep 443
 tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      2356/nginx: master  </code></pre>
<p>如果出现：nginx: [error] invalid PID number “” in “/run/nginx.pid”<br>则：<br>需要先执行  </p>
<pre><code>nginx -c /etc/nginx/nginx.conf  
 nginx -s reload    </code></pre>
<h2 id="2-6-访问测试"><a href="#2-6-访问测试" class="headerlink" title="2.6 访问测试"></a>2.6 访问测试</h2><p><img src="https://i.imgur.com/1SQGwCs.png"><br><img src="https://i.imgur.com/64MDD9F.png"></p>
<h1 id="三-https优化"><a href="#三-https优化" class="headerlink" title="三.https优化"></a>三.https优化</h1><p>  1.激活keeplive长连接<br>  2.设置ssl session缓存  </p>
<pre><code> server  
 &#123;  
 listen       443;
 server_name  10.10.11.221 liujie.com; 


  keepalive_timeout 100;    //nginx长连接——keepalive   默认为75s


 ssl on; 
 ssl_session_cache shared:SSL:10m;   //共享缓存 10m可存储8000-10000的session会话
 ssl_session_timeout 10m;    //10分钟session过期  


 ssl_certificate /etc/nginx/ssl_key/jesonc.crt; 
 ssl_certificate_key /etc/nginx/ssl_key/jesonc.key; 
 #ssl_certificate_key /etc/nginx/ssl_key/jesonc_nopass.key;  

 index index.html index.htm;
 location / &#123;       
      root  /opt/app/code;  
  &#125;
&#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/05/Nginx%E7%9A%84https%E6%9C%8D%E5%8A%A1/" data-id="ckibpb0ek000t8cj0bcei59t9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Nginx动静分离" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/05/Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/" class="article-date">
  <time datetime="2018-08-04T16:30:22.000Z" itemprop="datePublished">2018-08-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/05/Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/">Nginx动静分离</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="一-动静分离"><a href="#一-动静分离" class="headerlink" title="一.动静分离"></a>一.动静分离</h1><p>通过中间件将动态请求和静态请求分离&gt;&gt;减少不必要的请求消耗，减少请求延时。  ‘<br><img src="https://i.imgur.com/01SKLn0.png">  </p>
<hr>
<h1 id="二-配置动静分离"><a href="#二-配置动静分离" class="headerlink" title="二.配置动静分离"></a>二.配置动静分离</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>nginx服务器 redhat7 Nginx 10.10.11.221  </p>
<p>tomcat服务器 redhat7 tomcat+jdk 10.10.11.19  </p>
<hr>
<h2 id="2-2-准备测试文件"><a href="#2-2-准备测试文件" class="headerlink" title="2.2 准备测试文件"></a>2.2 准备测试文件</h2><h3 id="A："><a href="#A：" class="headerlink" title="A："></a>A：</h3><p>[root@liujie code]# vim /opt/app/code/test_mysite.html  </p>
<pre><code> &lt;html lang=&quot;en&quot;&gt;
 &lt;head&gt;  
 &lt;meta charset=&quot;UTF-8&quot; /&gt;  
 &lt;title&gt;测试ajax和跨域访问&lt;/title&gt;  
 &lt;script src=&quot;http://libs.baidu.com/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;  
 &lt;/head&gt;
 &lt;script type=&quot;text/javascript&quot;&gt;  
$(document).ready(function()&#123;  
        $.ajax(&#123;      //ajax调用 进行动态请求
        type: &quot;GET&quot;,  
        url: &quot;http://liujie.com/java_test.jsp&quot;,
        success: function(data) &#123;
               $(&quot;#get_data&quot;).html(data)
       &#125;,
        error: function() &#123;  
               alert(&quot;fail!!!,请刷新再试!&quot;);  
         &#125;  
      &#125;);  
 &#125;);  
&lt;/script&gt;
&lt;body&gt;
     &lt;h1&gt;测试动静分离&lt;/h1&gt;   
     &lt;img src=&quot;http://liujie.com/img/nginx.png&quot;/&gt;  //请求一张静态图片
     &lt;div id=&quot;get_data&quot;&gt;&lt;div&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="B：为nginx静态请求准备图片"><a href="#B：为nginx静态请求准备图片" class="headerlink" title="B：为nginx静态请求准备图片"></a>B：为nginx静态请求准备图片</h3><pre><code>[root@liujie code]# cd /opt/app/code/img/
[root@liujie img]# ll
total 4
 -rw-r--r-- 1 root root 2103 Aug  8  2017 nginx.png  </code></pre>
<h3 id="C-准备tomcat的动态页面"><a href="#C-准备tomcat的动态页面" class="headerlink" title="C:准备tomcat的动态页面"></a>C:准备tomcat的动态页面</h3><pre><code>[root@tomcat ROOT]# cd /usr/local/tomcat/webapps/ROOT/
[root@tomcat ROOT]# ll  
total 192  
 -rw-r----- 1 root root 27235 Nov  3 13:42 asf-logo-wide.svg  
 -rw-r----- 1 root root   713 Nov  3 13:39 bg-button.png
 -rw-r----- 1 root root  1918 Nov  3 13:39 bg-middle.png
 -rw-r----- 1 root root  1392 Nov  3 13:39 bg-nav-item.png
 -rw-r----- 1 root root  1401 Nov  3 13:39 bg-nav.png
 -rw-r----- 1 root root  3103 Nov  3 13:39 bg-upper.png
 -rw-r----- 1 root root 21630 Nov  3 13:39 favicon.ico
 -rw-r----- 1 root root 12290 Nov  3 13:42 index.jsp
 -rw-r--r-- 1 root root   343 Aug  8  2017 java_test.jsp    //动态页面
 -rw-r----- 1 root root  7142 Nov  3 13:42 RELEASE-NOTES.txt
 -rw-r----- 1 root root  5581 Nov  3 13:42 tomcat.css
 -rw-r----- 1 root root  2066 Nov  3 13:39 tomcat.gif  </code></pre>
<p>vim  java_test.jsp   //用于生成动态数字  </p>
<pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;TITLE&gt;JSP Test Page&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
    &lt;%
        Random rand = new Random();
        out.println(&quot;&lt;h1&gt;Random number:&lt;/h1&gt;&quot;);
        out.println(rand.nextInt(99)+100);
    %&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</code></pre>
<hr>
<h2 id="2-3-新建nginx下虚拟server"><a href="#2-3-新建nginx下虚拟server" class="headerlink" title="2.3 新建nginx下虚拟server"></a>2.3 新建nginx下虚拟server</h2><p>[root@liujie code]# vim /etc/nginx/conf.d/test_mysite.conf</p>
<pre><code>upstream java_api&#123; 
server 10.10.11.19:8080;  // 转发的服务器，upstream 为负载均衡做准备
 &#125;
 server &#123;
listen       80;
server_name  liujie.com;

#charset koi8-r;
access_log  /var/log/nginx/log/host.access.log  main;
root /opt/app/code;  // 静态资源存放目录

location ~ .*.jsp$ &#123;
    proxy_pass http://java_api;   // 动态请求的转发
    proxy_set_header Host $host;
    #index  index.html index.htm;
&#125;


location ~ \.(jpg|png|gif)$ &#123;   //  静态请求直接读取
    expires 1h;
    gzip on;
&#125;

 location /&#123;
    index  index.html index.htm;

&#125;

error_page   500 502 503 504 404  /50x.html;
location = /50x.html &#123;
    root   /usr/share/nginx/html;
&#125;  

 &#125;</code></pre>
<hr>
<h1 id="三-测试页面"><a href="#三-测试页面" class="headerlink" title="三.测试页面"></a>三.测试页面</h1><p>重启nginx tomcat </p>
<h2 id="3-1-需要配置谷歌浏览器，使浏览器支持跨域"><a href="#3-1-需要配置谷歌浏览器，使浏览器支持跨域" class="headerlink" title="3.1 需要配置谷歌浏览器，使浏览器支持跨域"></a>3.1 需要配置谷歌浏览器，使浏览器支持跨域</h2><p>首先需要关闭谷歌浏览器的所有窗口<br>右击谷歌浏览器图标——&gt;属性。弹出属性对话框。在目标栏最后添加 –args –disable-web-security –user-data-dir 注意空格<br><img src="https://i.imgur.com/hh6Ka6h.png"></p>
<p>再次打开谷歌会提示：<br><img src="https://i.imgur.com/g1HX1ae.png">  </p>
<hr>
<h2 id="3-2访问页面："><a href="#3-2访问页面：" class="headerlink" title="3.2访问页面："></a>3.2访问页面：</h2><p>刷新数字会变 则请求到了tomcat<br><img src="https://i.imgur.com/ZvyD97G.png"><br>停止tomcat：<br>静态页面正常展示<br><img src="https://i.imgur.com/m0Uj47s.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/05/Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/" data-id="ckibpb0eh000o8cj0200a6osg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LVS/">LVS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Zabbix/">Zabbix</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/02/test/">test</a>
          </li>
        
          <li>
            <a href="/2019/01/03/CloudBoot/">CloudBoot</a>
          </li>
        
          <li>
            <a href="/2019/01/01/LVS%E9%9B%86%E7%BE%A4-NAT%E6%A8%A1%E5%BC%8F/">LVS集群-NAT模式</a>
          </li>
        
          <li>
            <a href="/2018/12/13/Docker%E7%A7%81%E6%9C%89registry%20Harbor/">Docker私有registry Harbor</a>
          </li>
        
          <li>
            <a href="/2018/12/12/Docker%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/">Docker镜像管理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>